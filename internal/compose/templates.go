package compose

import (
	"bytes"
	"fmt"
	"os"
	"path/filepath"
	"text/template"
	"time"
)

// DockerComposeTemplate is the template for docker-compose.yml
const DockerComposeTemplate = `# Generated by servctl - Home Server Provisioning CLI
# DO NOT EDIT MANUALLY - Changes will be overwritten
# Generated at: {{ .GeneratedAt }}

services:
  # ============================================
  # Immich - Photo & Video Management
  # ============================================
  
  immich-server:
    container_name: immich_server
    image: ghcr.io/immich-app/immich-server:release
    restart: unless-stopped
    ports:
      - "{{ .Config.ImmichPort }}:2283"
    volumes:
      - {{ .Config.UploadPath }}:/usr/src/app/upload
      - /etc/localtime:/etc/localtime:ro
    environment:
      - TZ={{ .Config.Timezone }}
      - PUID={{ .Config.PUID }}
      - PGID={{ .Config.PGID }}
      - DB_HOSTNAME=immich-postgres
      - DB_USERNAME=immich
      - DB_PASSWORD={{ .Config.ImmichDBPassword }}
      - DB_DATABASE_NAME=immich
      - REDIS_HOSTNAME=immich-redis
    depends_on:
      - immich-redis
      - immich-postgres
    networks:
      - servctl-network

  immich-machine-learning:
    container_name: immich_machine_learning
    image: ghcr.io/immich-app/immich-machine-learning:release
    restart: unless-stopped
    volumes:
      - immich-model-cache:/cache
    environment:
      - TZ={{ .Config.Timezone }}
    networks:
      - servctl-network

  immich-redis:
    container_name: immich_redis
    image: docker.io/valkey/valkey:8-bookworm
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "valkey-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5
    volumes:
      - {{ .Config.DataRoot }}/cache:/data
    networks:
      - servctl-network

  immich-postgres:
    container_name: immich_postgres
    image: docker.io/tensorchord/pgvecto-rs:pg14-v0.2.0
    restart: unless-stopped
    environment:
      - POSTGRES_USER=immich
      - POSTGRES_PASSWORD={{ .Config.ImmichDBPassword }}
      - POSTGRES_DB=immich
      - POSTGRES_INITDB_ARGS="--data-checksums"
    volumes:
      - {{ .Config.DataRoot }}/databases/immich-postgres:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U immich -d immich"]
      interval: 10s
      timeout: 5s
      retries: 5
    networks:
      - servctl-network

  # ============================================
  # Nextcloud - File Sync & Share
  # ============================================

  nextcloud:
    container_name: nextcloud
    image: nextcloud:stable
    restart: unless-stopped
    ports:
      - "{{ .Config.NextcloudPort }}:80"
    volumes:
      - {{ .Config.DataRoot }}/cloud/data:/var/www/html
      - {{ .Config.DataRoot }}/cloud/config:/var/www/html/config
    environment:
      - TZ={{ .Config.Timezone }}
      - MYSQL_HOST=nextcloud-mariadb
      - MYSQL_DATABASE=nextcloud
      - MYSQL_USER=nextcloud
      - MYSQL_PASSWORD={{ .Config.NextcloudDBPassword }}
      - NEXTCLOUD_ADMIN_USER={{ .Config.NextcloudAdminUser }}
      - NEXTCLOUD_ADMIN_PASSWORD={{ .Config.NextcloudAdminPass }}
      - NEXTCLOUD_TRUSTED_DOMAINS={{ .Config.HostIP }} localhost
      - OVERWRITEPROTOCOL=http
      - OVERWRITEHOST={{ .Config.HostIP }}:{{ .Config.NextcloudPort }}
    depends_on:
      - nextcloud-mariadb
    networks:
      - servctl-network

  nextcloud-mariadb:
    container_name: nextcloud_mariadb
    image: mariadb:11
    restart: unless-stopped
    environment:
      - MYSQL_ROOT_PASSWORD={{ .Config.NextcloudDBPassword }}_root
      - MYSQL_DATABASE=nextcloud
      - MYSQL_USER=nextcloud
      - MYSQL_PASSWORD={{ .Config.NextcloudDBPassword }}
    volumes:
      - {{ .Config.DataRoot }}/databases/nextcloud-mariadb:/var/lib/mysql
    healthcheck:
      test: ["CMD", "healthcheck.sh", "--connect", "--innodb_initialized"]
      interval: 10s
      timeout: 5s
      retries: 5
    networks:
      - servctl-network

  # ============================================
  # Monitoring & Utilities
  # ============================================

  glances:
    container_name: glances
    image: nicolargo/glances:latest-full
    restart: unless-stopped
    pid: host
    network_mode: host
    environment:
      - TZ={{ .Config.Timezone }}
      - GLANCES_OPT=-w
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock:ro
      - /etc/os-release:/etc/os-release:ro
    cap_add:
      - SYS_ADMIN
      - SYS_RAWIO
    # Note: Glances uses host network, port {{ .Config.GlancesPort }}

  diun:
    container_name: diun
    image: crazymax/diun:latest
    restart: unless-stopped
    environment:
      - TZ={{ .Config.Timezone }}
      - DIUN_WATCH_SCHEDULE=0 0 */12 * * *
      - DIUN_PROVIDERS_DOCKER=true
      - DIUN_PROVIDERS_DOCKER_WATCHBYDEFAULT=true
{{- if .Config.DiscordWebhookURL }}
      - DIUN_NOTIF_DISCORD_WEBHOOKURL={{ .Config.DiscordWebhookURL }}
{{- end }}
{{- if .Config.TelegramBotToken }}
      - DIUN_NOTIF_TELEGRAM_TOKEN={{ .Config.TelegramBotToken }}
      - DIUN_NOTIF_TELEGRAM_CHATIDS={{ .Config.TelegramChatID }}
{{- end }}
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock:ro
      - diun-data:/data
    networks:
      - servctl-network

# ============================================
# Networks
# ============================================

networks:
  servctl-network:
    driver: bridge

# ============================================
# Volumes
# ============================================

volumes:
  immich-model-cache:
  diun-data:
`

// EnvFileTemplate is the template for .env file
const EnvFileTemplate = `# Generated by servctl - Home Server Provisioning CLI
# DO NOT EDIT MANUALLY - Changes will be overwritten
# Generated at: {{ .GeneratedAt }}

# ============================================
# System Settings
# ============================================
TZ={{ .Config.Timezone }}
PUID={{ .Config.PUID }}
PGID={{ .Config.PGID }}
HOST_IP={{ .Config.HostIP }}

# ============================================
# Paths (DO NOT CHANGE - Opinionated defaults)
# ============================================
DATA_ROOT={{ .Config.DataRoot }}
UPLOAD_LOCATION={{ .Config.UploadPath }}
INFRA_ROOT={{ .Config.InfraRoot }}

# ============================================
# Immich Configuration
# ============================================
IMMICH_PORT={{ .Config.ImmichPort }}
IMMICH_DB_PASSWORD={{ .Config.ImmichDBPassword }}

# ============================================
# Nextcloud Configuration
# ============================================
NEXTCLOUD_PORT={{ .Config.NextcloudPort }}
NEXTCLOUD_ADMIN_USER={{ .Config.NextcloudAdminUser }}
NEXTCLOUD_ADMIN_PASSWORD={{ .Config.NextcloudAdminPass }}
NEXTCLOUD_DB_PASSWORD={{ .Config.NextcloudDBPassword }}

# ============================================
# Glances Configuration
# ============================================
GLANCES_PORT={{ .Config.GlancesPort }}

# ============================================
# Notifications
# ============================================
{{- if .Config.DiscordWebhookURL }}
DISCORD_WEBHOOK_URL={{ .Config.DiscordWebhookURL }}
{{- end }}
{{- if .Config.TelegramBotToken }}
TELEGRAM_BOT_TOKEN={{ .Config.TelegramBotToken }}
TELEGRAM_CHAT_ID={{ .Config.TelegramChatID }}
{{- end }}
`

// TemplateData holds data for template rendering
type TemplateData struct {
	Config      *ServiceConfig
	GeneratedAt string
}

// GenerateDockerCompose generates the docker-compose.yml content
func GenerateDockerCompose(config *ServiceConfig) (string, error) {
	tmpl, err := template.New("docker-compose").Parse(DockerComposeTemplate)
	if err != nil {
		return "", fmt.Errorf("failed to parse template: %w", err)
	}

	data := TemplateData{
		Config:      config,
		GeneratedAt: fmt.Sprintf("%s", getCurrentTimestamp()),
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		return "", fmt.Errorf("failed to execute template: %w", err)
	}

	return buf.String(), nil
}

// GenerateEnvFile generates the .env content
func GenerateEnvFile(config *ServiceConfig) (string, error) {
	tmpl, err := template.New("env").Parse(EnvFileTemplate)
	if err != nil {
		return "", fmt.Errorf("failed to parse template: %w", err)
	}

	data := TemplateData{
		Config:      config,
		GeneratedAt: getCurrentTimestamp(),
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		return "", fmt.Errorf("failed to execute template: %w", err)
	}

	return buf.String(), nil
}

// getCurrentTimestamp returns current time as string
func getCurrentTimestamp() string {
	return fmt.Sprintf("%s", fmt.Sprintf("%v", time.Now().Format("2006-01-02 15:04:05")))
}

// WriteDockerCompose writes docker-compose.yml to disk
func WriteDockerCompose(config *ServiceConfig, outputDir string, dryRun bool) error {
	content, err := GenerateDockerCompose(config)
	if err != nil {
		return err
	}

	outputPath := filepath.Join(outputDir, "docker-compose.yml")

	if dryRun {
		fmt.Printf("[DRY RUN] Would write docker-compose.yml to %s\n", outputPath)
		fmt.Println("--- Content Preview ---")
		// Show first 50 lines
		lines := bytes.Split([]byte(content), []byte("\n"))
		for i, line := range lines {
			if i >= 50 {
				fmt.Println("... (truncated)")
				break
			}
			fmt.Println(string(line))
		}
		return nil
	}

	// Ensure directory exists
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}

	if err := os.WriteFile(outputPath, []byte(content), 0644); err != nil {
		return fmt.Errorf("failed to write docker-compose.yml: %w", err)
	}

	fmt.Printf("Generated: %s\n", outputPath)
	return nil
}

// WriteEnvFile writes .env to disk
func WriteEnvFile(config *ServiceConfig, outputDir string, dryRun bool) error {
	content, err := GenerateEnvFile(config)
	if err != nil {
		return err
	}

	outputPath := filepath.Join(outputDir, ".env")

	if dryRun {
		fmt.Printf("[DRY RUN] Would write .env to %s\n", outputPath)
		fmt.Println("--- Content Preview ---")
		fmt.Println(content)
		return nil
	}

	// Ensure directory exists
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}

	// .env should be more restrictive
	if err := os.WriteFile(outputPath, []byte(content), 0600); err != nil {
		return fmt.Errorf("failed to write .env: %w", err)
	}

	fmt.Printf("Generated: %s (mode 0600)\n", outputPath)
	return nil
}

// WriteAllConfigFiles writes both docker-compose.yml and .env
func WriteAllConfigFiles(config *ServiceConfig, outputDir string, dryRun bool) error {
	if err := WriteDockerCompose(config, outputDir, dryRun); err != nil {
		return err
	}
	if err := WriteEnvFile(config, outputDir, dryRun); err != nil {
		return err
	}
	return nil
}
