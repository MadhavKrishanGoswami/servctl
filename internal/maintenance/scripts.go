// Package maintenance handles generation of maintenance scripts and cron configuration.
// This includes backup scripts, health monitoring, and automated cleanup.
package maintenance

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"text/template"
)

// ScriptConfig holds configuration for maintenance scripts
type ScriptConfig struct {
	// Paths
	DataRoot   string // /mnt/data
	BackupDest string // /mnt/backup
	InfraRoot  string // ~/infra
	LogDir     string // ~/infra/logs

	// Drives to monitor
	Drives []string // e.g., ["/dev/sda", "/dev/sdb"]

	// Thresholds
	DiskAlertThreshold int // Percentage (default: 90)

	// Notification
	WebhookURL       string // Discord webhook URL
	TelegramBotToken string
	TelegramChatID   string

	// Backup settings
	BackupRetentionDays int // How many days to keep backups
}

// DefaultScriptConfig returns sensible defaults
func DefaultScriptConfig() *ScriptConfig {
	return &ScriptConfig{
		DataRoot:            "/mnt/data",
		BackupDest:          "/mnt/backup",
		InfraRoot:           "",
		LogDir:              "",
		Drives:              []string{"/dev/sda"},
		DiskAlertThreshold:  90,
		BackupRetentionDays: 7,
	}
}

// DailyBackupTemplate is the template for the daily backup script
const DailyBackupTemplate = `#!/bin/bash
# Generated by servctl - Daily Backup Script
# Runs: Daily at configured time

# --- CONFIGURATION ---
SOURCE="{{ .DataRoot }}/"
DEST="{{ .BackupDest }}/"
LOGFILE="{{ .LogDir }}/daily_backup.log"
WEBHOOK_URL="{{ .WebhookURL }}"

echo "[$(date)] Starting Backup..." >> $LOGFILE

# --- RUN RSYNC ---
rsync -av --delete $SOURCE $DEST >> $LOGFILE 2>&1
EXIT_CODE=$?

# --- GET DISK STATS ---
DATA_USAGE=$(df -h {{ .DataRoot }} | awk 'NR==2 {print $3 "/" $2 " (" $5 ")"}')
BACKUP_USAGE=$(df -h {{ .BackupDest }} | awk 'NR==2 {print $3 "/" $2 " (" $5 ")"}')

# --- NOTIFICATION LOGIC ---
if [ $EXIT_CODE -eq 0 ]; then
    COLOR=3066993  # GREEN
    TITLE="âœ… NAS Backup: Success"
    DESC="The nightly sync completed successfully."
else
    COLOR=15158332 # RED
    TITLE="ðŸš¨ NAS Backup: FAILED"
    DESC="Check the logs immediately. Exit Code: $EXIT_CODE"
fi

# --- CONSTRUCT JSON PAYLOAD ---
generate_post_data() {
  cat <<EOF
{
  "username": "NAS Guardian",
  "embeds": [{
    "title": "$TITLE",
    "description": "$DESC",
    "color": $COLOR,
    "fields": [
      {
        "name": "ðŸ“¦ Data Pool",
        "value": "$DATA_USAGE",
        "inline": true
      },
      {
        "name": "ðŸ”’ Backup Pool",
        "value": "$BACKUP_USAGE",
        "inline": true
      }
    ],
    "footer": {
      "text": "Log: $LOGFILE â€¢ $(date)"
    }
  }]
}
EOF
}

# --- SEND TO DISCORD ---
{{- if .WebhookURL }}
curl -s -H "Content-Type: application/json" \
     -X POST \
     -d "$(generate_post_data)" \
     $WEBHOOK_URL >> $LOGFILE 2>&1
{{- end }}

echo "[$(date)] Backup Finished (Exit Code: $EXIT_CODE)." >> $LOGFILE
`

// DiskAlertTemplate is the template for disk usage monitoring
const DiskAlertTemplate = `#!/bin/bash
# Generated by servctl - Disk Usage Alert Script
# Runs: Every 6 hours

# --- CONFIGURATION ---
THRESHOLD={{ .DiskAlertThreshold }}
PARTITION="{{ .DataRoot }}"
WEBHOOK_URL="{{ .WebhookURL }}"

# Get usage percentage (numbers only)
USAGE=$(df -h "$PARTITION" | awk 'NR==2 {print $5}' | sed 's/%//g')

# --- CHECK LOGIC ---
if [ "$USAGE" -gt "$THRESHOLD" ]; then
    
    # JSON Payload for Discord
    json_payload=$(cat <<EOF
{
  "username": "Server Alerter",
  "embeds": [{
    "title": "ðŸš¨ CRITICAL: DISK FULL",
    "description": "Storage is running out! Server functionality may break soon.",
    "color": 15158332,
    "fields": [
      {
        "name": "Partition",
        "value": "$PARTITION",
        "inline": true
      },
      {
        "name": "Current Usage",
        "value": "${USAGE}%",
        "inline": true
      },
      {
        "name": "Threshold",
        "value": "${THRESHOLD}%",
        "inline": true
      }
    ]
  }]
}
EOF
)

    # Send Alert
{{- if .WebhookURL }}
    curl -s -H "Content-Type: application/json" \
         -X POST \
         -d "$json_payload" \
         $WEBHOOK_URL
{{- end }}
fi
`

// SmartAlertTemplate is the template for SMART health monitoring
const SmartAlertTemplate = `#!/bin/bash
# Generated by servctl - SMART Health Alert Script
# Runs: Daily

# --- CONFIGURATION ---
DRIVES=({{ range .Drives }}"{{ . }}" {{ end }})
WEBHOOK_URL="{{ .WebhookURL }}"

# --- LOOP THROUGH DRIVES ---
for DRIVE in "${DRIVES[@]}"; do
    
    # 1. Get Health Status
    HEALTH=$(sudo smartctl -H $DRIVE | grep "overall-health" | awk -F: '{print $2}' | tr -d ' ')

    # 2. Check for Failure
    if [ "$HEALTH" != "PASSED" ]; then
        
        # PREPARE ALERT
        TITLE="ðŸš¨ DRIVE FAILURE: $DRIVE"
        DESC="Physical drive $DRIVE is failing S.M.A.R.T. checks. Status: ${HEALTH:-UNKNOWN}"
        COLOR=15158332 # RED
        
        # JSON PAYLOAD
        json_payload=$(cat <<EOF
{
  "username": "Disk Doctor",
  "embeds": [{
    "title": "$TITLE",
    "description": "$DESC",
    "color": $COLOR,
    "fields": [
      { "name": "Drive", "value": "$DRIVE", "inline": true },
      { "name": "Health Status", "value": "${HEALTH:-CRITICAL}", "inline": true }
    ]
  }]
}
EOF
)
        # SEND TO DISCORD
{{- if .WebhookURL }}
        curl -s -H "Content-Type: application/json" -X POST -d "$json_payload" $WEBHOOK_URL
{{- end }}
    fi
done
`

// WeeklyCleanupTemplate is the template for weekly system cleanup
const WeeklyCleanupTemplate = `#!/bin/bash
# Generated by servctl - Weekly Cleanup Script
# Runs: Weekly (Sunday by default)

# --- CONFIGURATION ---
LOGFILE="{{ .LogDir }}/weekly_cleanup.log"
WEBHOOK_URL="{{ .WebhookURL }}"

echo "[$(date)] Starting Weekly Cleanup..." > $LOGFILE

# --- GET BEFORE STATS ---
BEFORE_USAGE=$(df -h {{ .DataRoot }} | awk 'NR==2 {print $5}')

# 1. CLEAN APT (System Packages)
sudo apt-get clean >> $LOGFILE 2>&1
sudo apt-get autoremove -y >> $LOGFILE 2>&1

# 2. CLEAN DOCKER (The Safe Way)
# Only remove "dangling" images (safe operation)
docker image prune -f >> $LOGFILE 2>&1

# 3. CLEAN OLD LOGS (prevent huge logs)
# Truncate logs larger than 50MB
find /var/log -type f -name "*.log" -size +50M -exec truncate -s 0 {} \; 2>/dev/null

# 4. CLEAN OLD BACKUPS (optional)
{{- if .BackupDest }}
find {{ .BackupDest }} -type f -name "*.tar.gz" -mtime +{{ .BackupRetentionDays }} -delete 2>/dev/null
{{- end }}

# --- GET AFTER STATS ---
AFTER_USAGE=$(df -h {{ .DataRoot }} | awk 'NR==2 {print $5}')
DISK_INFO=$(df -h {{ .DataRoot }} | awk 'NR==2 {print $3 "/" $2}')

# --- NOTIFICATION ---
{{- if .WebhookURL }}
json_payload=$(cat <<EOF
{
  "username": "Janitor",
  "embeds": [{
    "title": "ðŸ§¹ Weekly Cleanup Complete",
    "description": "System maintenance completed successfully.",
    "color": 3066993,
    "fields": [
      { "name": "Before", "value": "$BEFORE_USAGE", "inline": true },
      { "name": "After", "value": "$AFTER_USAGE", "inline": true },
      { "name": "Storage Used", "value": "$DISK_INFO", "inline": true }
    ]
  }]
}
EOF
)

curl -s -H "Content-Type: application/json" -X POST -d "$json_payload" $WEBHOOK_URL >> $LOGFILE 2>&1
{{- end }}

echo "[$(date)] Cleanup Finished." >> $LOGFILE
`

// generateScript executes a template and returns the script content
func generateScript(tmplName, tmplContent string, config *ScriptConfig) (string, error) {
	tmpl, err := template.New(tmplName).Parse(tmplContent)
	if err != nil {
		return "", fmt.Errorf("failed to parse template: %w", err)
	}

	var buf strings.Builder
	if err := tmpl.Execute(&buf, config); err != nil {
		return "", fmt.Errorf("failed to execute template: %w", err)
	}

	return buf.String(), nil
}

// GenerateDailyBackup generates the daily backup script
func GenerateDailyBackup(config *ScriptConfig) (string, error) {
	return generateScript("daily_backup", DailyBackupTemplate, config)
}

// GenerateDiskAlert generates the disk alert script
func GenerateDiskAlert(config *ScriptConfig) (string, error) {
	return generateScript("disk_alert", DiskAlertTemplate, config)
}

// GenerateSmartAlert generates the SMART alert script
func GenerateSmartAlert(config *ScriptConfig) (string, error) {
	return generateScript("smart_alert", SmartAlertTemplate, config)
}

// GenerateWeeklyCleanup generates the weekly cleanup script
func GenerateWeeklyCleanup(config *ScriptConfig) (string, error) {
	return generateScript("weekly_cleanup", WeeklyCleanupTemplate, config)
}

// ScriptInfo describes a generated script
type ScriptInfo struct {
	Name        string
	Filename    string
	Description string
	Schedule    string
	Content     string
}

// GenerateAllScripts generates all maintenance scripts
func GenerateAllScripts(config *ScriptConfig) ([]ScriptInfo, error) {
	scripts := []ScriptInfo{}

	// Daily backup
	content, err := GenerateDailyBackup(config)
	if err != nil {
		return nil, fmt.Errorf("daily_backup: %w", err)
	}
	scripts = append(scripts, ScriptInfo{
		Name:        "Daily Backup",
		Filename:    "daily_backup.sh",
		Description: "Syncs data to backup with rsync",
		Schedule:    "Daily at 4:00 AM",
		Content:     content,
	})

	// Disk alert
	content, err = GenerateDiskAlert(config)
	if err != nil {
		return nil, fmt.Errorf("disk_alert: %w", err)
	}
	scripts = append(scripts, ScriptInfo{
		Name:        "Disk Usage Alert",
		Filename:    "disk_alert.sh",
		Description: fmt.Sprintf("Alerts when disk usage exceeds %d%%", config.DiskAlertThreshold),
		Schedule:    "Every 6 hours",
		Content:     content,
	})

	// SMART alert
	content, err = GenerateSmartAlert(config)
	if err != nil {
		return nil, fmt.Errorf("smart_alert: %w", err)
	}
	scripts = append(scripts, ScriptInfo{
		Name:        "SMART Health Check",
		Filename:    "smart_alert.sh",
		Description: "Monitors drive health via SMART",
		Schedule:    "Daily at 5:00 AM",
		Content:     content,
	})

	// Weekly cleanup
	content, err = GenerateWeeklyCleanup(config)
	if err != nil {
		return nil, fmt.Errorf("weekly_cleanup: %w", err)
	}
	scripts = append(scripts, ScriptInfo{
		Name:        "Weekly Cleanup",
		Filename:    "weekly_cleanup.sh",
		Description: "Cleans apt cache, Docker, and old logs",
		Schedule:    "Sunday at 3:00 AM",
		Content:     content,
	})

	return scripts, nil
}

// WriteScript writes a script to disk with executable permissions
func WriteScript(script ScriptInfo, outputDir string, dryRun bool) error {
	outputPath := filepath.Join(outputDir, script.Filename)

	if dryRun {
		fmt.Printf("[DRY RUN] Would write %s to %s\n", script.Name, outputPath)
		return nil
	}

	// Ensure directory exists
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		return fmt.Errorf("failed to create directory: %w", err)
	}

	// Write script
	if err := os.WriteFile(outputPath, []byte(script.Content), 0755); err != nil {
		return fmt.Errorf("failed to write script: %w", err)
	}

	fmt.Printf("Generated: %s (mode 0755)\n", outputPath)
	return nil
}

// WriteAllScripts writes all maintenance scripts
func WriteAllScripts(config *ScriptConfig, outputDir string, dryRun bool) ([]ScriptInfo, error) {
	scripts, err := GenerateAllScripts(config)
	if err != nil {
		return nil, err
	}

	for _, script := range scripts {
		if err := WriteScript(script, outputDir, dryRun); err != nil {
			return scripts, err
		}
	}

	return scripts, nil
}
