package maintenance

import (
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
)

// CronSchedule represents a cron job schedule
type CronSchedule struct {
	Minute     string // 0-59 or *
	Hour       string // 0-23 or *
	DayOfMonth string // 1-31 or *
	Month      string // 1-12 or *
	DayOfWeek  string // 0-7 (0 and 7 are Sunday) or *
}

// String returns the cron schedule in standard format
func (c CronSchedule) String() string {
	return fmt.Sprintf("%s %s %s %s %s",
		c.Minute, c.Hour, c.DayOfMonth, c.Month, c.DayOfWeek)
}

// HumanReadable returns a human-readable description
func (c CronSchedule) HumanReadable() string {
	// Every X hours
	if strings.HasPrefix(c.Hour, "*/") {
		return fmt.Sprintf("Every %s hours", strings.TrimPrefix(c.Hour, "*/"))
	}
	// Daily at specific time
	if c.Minute == "0" && c.Hour != "*" && c.DayOfMonth == "*" && c.Month == "*" && c.DayOfWeek == "*" {
		return fmt.Sprintf("Daily at %s:00", c.Hour)
	}
	// Weekly on Sunday
	if c.DayOfWeek == "0" {
		return fmt.Sprintf("Sunday at %s:%s", c.Hour, c.Minute)
	}
	return c.String()
}

// CronJob represents a cron job entry
type CronJob struct {
	Name        string
	Schedule    CronSchedule
	Command     string
	Description string
	User        string // Usually "root" for system cron
}

// DefaultCronJobs returns the default cron job configuration
func DefaultCronJobs(scriptsDir string) []CronJob {
	return []CronJob{
		{
			Name:        "daily_backup",
			Schedule:    CronSchedule{Minute: "0", Hour: "4", DayOfMonth: "*", Month: "*", DayOfWeek: "*"},
			Command:     filepath.Join(scriptsDir, "daily_backup.sh"),
			Description: "Daily backup at 4:00 AM",
			User:        "root",
		},
		{
			Name:        "disk_alert",
			Schedule:    CronSchedule{Minute: "0", Hour: "*/6", DayOfMonth: "*", Month: "*", DayOfWeek: "*"},
			Command:     filepath.Join(scriptsDir, "disk_alert.sh"),
			Description: "Check disk usage every 6 hours",
			User:        "root",
		},
		{
			Name:        "smart_alert",
			Schedule:    CronSchedule{Minute: "0", Hour: "5", DayOfMonth: "*", Month: "*", DayOfWeek: "*"},
			Command:     filepath.Join(scriptsDir, "smart_alert.sh"),
			Description: "SMART health check at 5:00 AM",
			User:        "root",
		},
		{
			Name:        "weekly_cleanup",
			Schedule:    CronSchedule{Minute: "0", Hour: "3", DayOfMonth: "*", Month: "*", DayOfWeek: "0"},
			Command:     filepath.Join(scriptsDir, "weekly_cleanup.sh"),
			Description: "Weekly cleanup on Sunday at 3:00 AM",
			User:        "root",
		},
	}
}

// CronFileContent generates the content for /etc/cron.d/servctl
const CronFileTemplate = `# servctl - Automated Maintenance Jobs
# Generated by servctl - DO NOT EDIT MANUALLY
# 
# This file is placed in /etc/cron.d/ and runs as root.
# See crontab(5) for schedule format.

SHELL=/bin/bash
PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin

# Format: minute hour day month dayofweek user command

{{ range . }}
# {{ .Description }}
{{ .Schedule.String }} {{ .User }} {{ .Command }}
{{ end }}
`

// GenerateCronFile generates the cron file content
func GenerateCronFile(jobs []CronJob) (string, error) {
	tmpl := `# servctl - Automated Maintenance Jobs
# Generated by servctl - DO NOT EDIT MANUALLY
# 
# This file is placed in /etc/cron.d/ and runs as root.
# See crontab(5) for schedule format.

SHELL=/bin/bash
PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin

# Format: minute hour day month dayofweek user command
`

	var b strings.Builder
	b.WriteString(tmpl)

	for _, job := range jobs {
		b.WriteString(fmt.Sprintf("\n# %s\n", job.Description))
		b.WriteString(fmt.Sprintf("%s %s %s\n",
			job.Schedule.String(),
			job.User,
			job.Command,
		))
	}

	return b.String(), nil
}

// WriteCronFile writes the cron configuration to /etc/cron.d/servctl
func WriteCronFile(jobs []CronJob, dryRun bool) error {
	content, err := GenerateCronFile(jobs)
	if err != nil {
		return err
	}

	cronPath := "/etc/cron.d/servctl"

	if dryRun {
		fmt.Printf("[DRY RUN] Would write to %s:\n", cronPath)
		fmt.Println("--- Content ---")
		fmt.Println(content)
		return nil
	}

	// Write file (requires root)
	if err := os.WriteFile(cronPath, []byte(content), 0644); err != nil {
		return fmt.Errorf("failed to write cron file (are you root?): %w", err)
	}

	fmt.Printf("Generated: %s (mode 0644)\n", cronPath)
	return nil
}

// IsCronInstalled checks if cron is available
func IsCronInstalled() bool {
	_, err := exec.LookPath("crontab")
	return err == nil
}

// CronExists checks if servctl cron file already exists
func CronExists() bool {
	_, err := os.Stat("/etc/cron.d/servctl")
	return err == nil
}

// RemoveCronFile removes the servctl cron configuration
func RemoveCronFile(dryRun bool) error {
	cronPath := "/etc/cron.d/servctl"

	if dryRun {
		fmt.Printf("[DRY RUN] Would remove %s\n", cronPath)
		return nil
	}

	if err := os.Remove(cronPath); err != nil && !os.IsNotExist(err) {
		return fmt.Errorf("failed to remove cron file: %w", err)
	}

	return nil
}

// LogrotateConfig generates the logrotate configuration
const LogrotateTemplate = `# servctl - Log Rotation Configuration
# Place in /etc/logrotate.d/servctl

{{ .LogDir }}/*.log {
    weekly
    rotate 4
    compress
    delaycompress
    missingok
    notifempty
    create 0644 {{ .User }} {{ .User }}
}
`

// GenerateLogrotateConfig generates logrotate configuration
func GenerateLogrotateConfig(logDir, user string) string {
	return fmt.Sprintf(`# servctl - Log Rotation Configuration
# Place in /etc/logrotate.d/servctl

%s/*.log {
    weekly
    rotate 4
    compress
    delaycompress
    missingok
    notifempty
    create 0644 %s %s
}
`, logDir, user, user)
}

// WriteLogrotateConfig writes the logrotate configuration
func WriteLogrotateConfig(logDir, user string, dryRun bool) error {
	content := GenerateLogrotateConfig(logDir, user)
	logrotPath := "/etc/logrotate.d/servctl"

	if dryRun {
		fmt.Printf("[DRY RUN] Would write to %s:\n", logrotPath)
		fmt.Println("--- Content ---")
		fmt.Println(content)
		return nil
	}

	if err := os.WriteFile(logrotPath, []byte(content), 0644); err != nil {
		return fmt.Errorf("failed to write logrotate config (are you root?): %w", err)
	}

	fmt.Printf("Generated: %s\n", logrotPath)
	return nil
}

// TestWebhook sends a test notification to verify webhook is working
func TestWebhook(webhookURL string, dryRun bool) error {
	if webhookURL == "" {
		return fmt.Errorf("webhook URL is empty")
	}

	payload := `{
  "username": "servctl",
  "embeds": [{
    "title": "âœ… Webhook Test Successful",
    "description": "Your webhook is configured correctly. You will receive server notifications here.",
    "color": 3066993
  }]
}`

	if dryRun {
		fmt.Printf("[DRY RUN] Would send test notification to webhook\n")
		return nil
	}

	cmd := exec.Command("curl", "-s",
		"-H", "Content-Type: application/json",
		"-X", "POST",
		"-d", payload,
		webhookURL,
	)

	output, err := cmd.CombinedOutput()
	if err != nil {
		return fmt.Errorf("webhook test failed: %s: %w", string(output), err)
	}

	// Check for Discord error response
	if strings.Contains(string(output), "error") {
		return fmt.Errorf("webhook returned error: %s", string(output))
	}

	return nil
}
